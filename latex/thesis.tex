
% Cal Poly Thesis
% 
% based on UC Thesis format
%
% modified by Mark Barry 2/07.
%




\documentclass[12pt]{ucthesis}

%\newif\ifpdf
%\ifx\pdfoutput\undefined
%    \pdffalse % we are not running PDFLaTeX
%\else
%\pdfoutput=1 % we are running PDFLaTeX
%\pdftrue \fi

\usepackage{textcomp}
\usepackage{url}
\usepackage{listings}
\lstset{
    language=[Visual]C++,
    keywordstyle=\bfseries\ttfamily\color[rgb]{0,0,1},
    identifierstyle=\ttfamily,
    commentstyle=\color[rgb]{0.133,0.545,0.133},
    stringstyle=\ttfamily\color[rgb]{0.627,0.126,0.941},
    showstringspaces=false,
    basicstyle=\small,
    numberstyle=\footnotesize,
    numbers=left,
    stepnumber=1,
    numbersep=10pt,
    tabsize=2,
    breaklines=true,
    prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
    breakatwhitespace=false,
    aboveskip={1.5\baselineskip},
  columns=fixed,
  upquote=true,
  extendedchars=true
% frame=single,
% backgroundcolor=\color{lbcolor},
}
\usepackage{color}
%\usepackage{ifpdf}
%\ifpdf

    \usepackage[pdftex]{graphicx}
    % Update title and author below...
    \usepackage[pdftex,plainpages=false,breaklinks=true,colorlinks=true,urlcolor=blue,citecolor=blue,%
                                       linkcolor=blue,bookmarks=true,bookmarksopen=true,%
                                       bookmarksopenlevel=3,pdfstartview=FitV,
                                       pdfauthor=Ryan Schmitt,
                                       pdftitle=GPU-Accelerated Point-Based Color Bleeding,
                                       pdfkeywords={thesis, masters, cal poly, rendering, global illumination, GPU, acceleration}
                                       ]{hyperref}
    %Options with pdfstartview are FitV, FitB and FitH
    \pdfcompresslevel=1

%\else
%    \usepackage{graphicx}
%\fi

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[letterpaper]{geometry}
\usepackage[overload]{textcase}



\bibliographystyle{abbrv}

\setlength{\parindent}{0.25in} \setlength{\parskip}{6pt}

\geometry{verbose,nohead,tmargin=1.25in,bmargin=1in,lmargin=1.5in,rmargin=1.3in}

\setcounter{tocdepth}{2}


% Different font in captions (single-spaced, bold) ------------
\newcommand{\captionfonts}{\small\bf\ssp}

\makeatletter  % Allow the use of @ in command names
\long\def\@makecaption#1#2{%
  \vskip\abovecaptionskip
  \sbox\@tempboxa{{\captionfonts #1: #2}}%
  \ifdim \wd\@tempboxa >\hsize
    {\captionfonts #1: #2\par}
  \else
    \hbox to\hsize{\hfil\box\@tempboxa\hfil}%
  \fi
  \vskip\belowcaptionskip}
\makeatother   % Cancel the effect of \makeatletter
% ---------------------------------------

\begin{document}

% Declarations for Front Matter

% Update fields below!
\title{GPU-Accelerated Point-Based Color Bleeding}
\author{Ryan Schmitt}
\degreemonth{December} \degreeyear{2011} \degree{Master of Science}
\defensemonth{December} \defenseyear{2011}
\numberofmembers{3} \chair{Zo\"{e} Wood, Ph.D.} \othermemberA{Chris Lupo, Ph.D.} \othermemberB{Michael Haungs, Ph.D.} \field{Computer Science} \campus{San Luis Obispo}
\copyrightyears{seven}



\maketitle

\begin{frontmatter}

% Custom made for Cal Poly (by Mark Barry, modified by Andrew Tsui).
\copyrightpage

% Custom made for Cal Poly (by Andrew Tsui).
\committeemembershippage

%---- Abstract ----
\begingroup
\input{../sections/Abstract.tex}
\endgroup

\begin{acknowledgements}

   Thank you...

\end{acknowledgements}


\tableofcontents

\listoftables

\listoffigures

\end{frontmatter}

\pagestyle{plain}

\renewcommand{\baselinestretch}{1.66}


% ------------- Main chapters here --------------------

%---- Introduction ----
\begingroup
\input{../sections/Introduction.tex}
\endgroup

%---- Background ----
%\begingroup
%\input{../sections/Background.tex}
%\endgroup

%% ------------- End main chapters ----------------------

\clearpage
\bibliography{thesis}
%\bibliographystyle{plain}
%%\addcontentsline{toc}{chapter}{Bibliography}

%\chapter{Related Work}
%
%\section{Global Illumination}
%Global illumination is an important field of study in computer graphics that numerous successful algorithms including photon mapping \cite{Jensen:2009}, radiosity \cite{radiosity} and Monte Carlo sampling techniques \cite{monte_carlo} try to mitigate or overcome in a reasonable time-frame.  Most commonly implemented methods are those that sample the scene and use a two phase approach (sample and gather) to model direct illumination and indirect illumination.  The gather stage included in most algorithms is built to be more efficient or lower resolution than the scene being rendered, which helps reduce the lighting computation cost.
%
%\subsection{PCB}
%Of particular relevance to this field is the work done in Point-Based Approximate Color Bleeding developed by Per Christensen \cite{christensen:2008}.  With this method, a subset of the scene geometry is thoroughly sampled, creating a point cloud representation of the direct lighting at each sample, which is then used to evaluate the incoming radiance surrounding a given point on a surface.
%
%As recently as 2010, discussion of approximating volume scattering using point clouds has been discussed \cite{christensen:siggraph}, however no specifics have been offered to how \textit{back-to-front or front-to-back rasterization} would be achieved with the current rasterization method (handled by our octree traversal method) or how scatter, extinction and absorption would be managed within the three-dimensional volume representation inside the point cloud.
%
%\subsection{Photon Mapping}
%Another closely related area of study includes photon mapping, a method that attempts to simulate light scatter and absorption properties of participating media, which has shown promise in the past.  In \cite{jensen:1998}, Jensen describes a process where photons participate and become stored inside the volume itself for later gathers during volume integration.  These photons are able to simulate scatter, absorption and passing through material (both geometric and volumetric.)
%
%While this technique is shown to work, it primarily focuses on caustic effects in volumes and the generated photon map.  Our storage method does not require data to be stored in the volume itself (as would be the case in photon mapping,) but in a separate, more lightweight data-structure better suited for out-of-core rendering.
%
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=100mm]{img/external/ewr7_mcbox.jpg}
%    \caption{Global illumination example achieved via photon mapping.  Source: http://graphics.ucsd.edu/\string~henrik/papers/photon\_map/}
%    \label{fig:photon}
%\end{figure}
%
%\section{Volume Rendering}
%This paper is focused on the lighting and rendering of scenes which contain volume data.  A number of approaches have been developed in order to represent volume data through computer visualizations or renders~\cite{Kajiya84},\cite{levoy88}.
%
%\subsection{Existing Work}
%Some of the first proposed volume rendering and shading techniques are described in \cite{levoy88}.  Before the time of the paper's creation, many of the accepted methods of volume visualization involved generating polygonal representations of the volumes by sampling the opacities and comparing them to a selected isovalue to determine whether or not the voxel is designated as ``inside'' the volume or ``outside.''  A polygonal mesh is then constructed based on this differentiating boundary.  Unfortunately, the algorithm defined above fell prey to spurious surfaces and holes caused by a limited sample range (since the polygonal method suffered from having to make a binary decision.  Either a ray intersected the volume or it did not.)
%
%In response to this, Levoy proposed a process of testing against two arrays (one with opacities and one with colors) that represent the voxel data-structure.  If a voxel was intersected, the algorithm would interpolate its color and opacity to those surrounding it based on the nature of the intersection.  This allowed for transparent volumes, and also allowed for opacities to be separated from voxel color, allowing for some important pre-processing to be done on the data such as volume classification, where the opacity of a volume is determined on an iso-range.  This in turn allowed the renderer to focus attention to specific densities in scans (useful for medical imaging.)
%
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=100mm]{img/external/img188.png}
%    \caption{Volume renders from \cite{levoy88} showing CT scan volume data visualized in three-dimensions, complete with realistic lighting. }
%    \label{fig:levoy}
%\end{figure}
%
%\subsection{Multi-Resolution Volumes}
%Because of the complexity of volume data (both through data representation and computation,) volume rendering algorithms often implement efficient multi-resolution data representation~\cite{Westermann94}.  \cite{Levoy90} describes a hierarchical method of managing a volume data set in order to remove unnecessary ``Empty'' cells and to reduce the amount of intersection tests done on voxels (or ``Cells'', as the higher level nodes are referred to.)  This algorithm introduced the use of octrees as an efficient means of dividing and containing the volume data.
%
%Our algorithm implements a sparse octree data-structure for both the volumes in the scene and the point-cloud used for the indirect lighting equation.
%
%\subsection{Occlusion Techniques}
%Another method to accelerate volume rendering involves estimating what nodes in a volume octree are definitely occluded based on surrounding node densities.  \cite{guthe} describes building a two-dimensional occlusion map and filling it in over a series of iterations, removing occluded nodes from being tested each iteration.  This method has been shown to drastically increase rendering performance by removing as much as 30\% per iteration.
%
%Based on many existing volume rendering algorithms, our implementation takes advantage of a multi-resolution, view-independent octree data-structure in order to handle a large amount of complex lighting and volume data.  We then use this very same octree representation to evaluate occluded regions, skipping scene data occluded by opaque geometry cached in the data-structure in the form of surfels.
%
%\subsection{Volume Lighting}
%As our computational power has improved, we have been able to tackle problems in lighting that we could not have overcome in the past.  \cite{kniss:03} builds upon Levoy's volume rendering method by implementing shadowing by sending shadow rays toward each light for each sample within the volume in order to estimate the amount of extinction between the point and the light.  Indirect lighting is also employed (though only forward-scattering due to the incremental nature of their algorithm.)
%
%\cite{zhang} attempts to handle multiple-scattering and volume shadows in scenes that sport mixed polygonal and volumetric data.  The paper describes light scatter representations similar to Equations \ref{siga_eq}, \ref{sigs_eq}, \ref{eq:sigt}, where light is able to scatter in and out from the sampling ray.  The algorithm then handles volume shadows caused by polygonal mesh data by constructing a series of shadow buffers, evaluating the volume shadow as a texture at each slice.
%
%While our volume lighting equation takes into account volume scatter properties, we do not evaluate shadows in a separate pass.  Instead, our algorithm not only evaluates transmittance between arbitrary sample points and the scene lights (giving us believable direct lighting), but we simulate scatter in properties by casting Monte Carlo samples out into our point-cloud to evaluate scene and volume radiance.  Additionally, our point cloud is not constrained by our traversal method, so all forms of scatter are supported.  Finally, the algorithm described also does not handle scatter out contributions to the scene, where the volume data may contribute to the rest of the scene's lighting.
%
%%==============================================================================%
%\chapter{PCB Extension Algorithm}
%\label{algorithm_sec}
%We present an algorithm which is an extension to the point cloud techniques described in \cite{tabellion} and \cite{christensen:2008}, specifically building off the point-based color bleeding (PCB) technique by Christensen.  The modifications involve evaluating light scatter and absorption properties at discrete points in the volume and adding them to the point cloud.  Using a front-to-back traversal method, we can correctly and quickly approximate the \textit{light-volume} representation's contribution to a scene's indirect lighting evaluation.
%
%\section{Point Based Color Bleeding}
%
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=100mm]{img/pcloud.png}
%    \caption{An example of a point-cloud scene where the geometry had been sampled, a disc representation replacing the geometry.  The radii of the discs in this image are reduced to better exemplify their presence.}
%    \label{fig:pcloud}
%\end{figure}
%
%In general, the color-bleeding algorithm subdivide the world into small representational segments, called surfels in \cite{christensen:2008}, which are stored in a large point cloud, representing the scene (See Figure \ref{fig:pcloud}.)  Surfels are used to model direct illumination, and are then used in a later phase to compute indirect lighting and color bleeding in an efficient manner.  This method is split up into three stages:
%
%\begin{enumerate}
%\item Sample the scene and save a discrete representation of the surfaces along with direct lighting in a point cloud
%\item Perform normal ray tracing on the scene geometry
%\item Replace ambient estimates with a gather stage, sampling the scene around a point to gather the indirect lighting component
%\end{enumerate}
%
%The goal of our proposed method is to include volumetric representations into a global illumination algorithm in a fast and coherent way similar to how surfels are represented in the point cloud.
%
%\section{Extension Overview}
%
%In the existing algorithms~\cite{christensen:2008}, surfels represent opaque materials within the point cloud.  Thus to incorporate a representation of volumetric data, an additional data representation was necessary to handle the scatter and absorption properties of participating media.  In general, our data representation closely follows the model of surfels, in that we choose to sample the volume at discrete locations and store a finite representation of the lighting at those discrete locations, but with modifications to handle the special attributes of lighting in transparent media.  In keeping with the naming conventions established, we call our discrete sampling of lighting elements for a volume: \emph{lvoxels}.  
%
%As a quick review, our algorithm must do the following:
%\begin{enumerate}
%\item Sample the scene geometry and store the direct lighting (or relevant lighting properties) within an acceleration structure for fast evaluation
%\item Sample the participating media and evaluate scatter, absorption and direct lighting at each discrete point
%\item Identify points of interest during regular ray casts using scene geometry 
%\item Orient a set of hemispherical samples along the normals of ray cast surfaces and cast the rays into the point-cloud
%\item Model the scatter-out and scatter-in properties of volumetric lighting during the indirect lighting gather stage.
%\end{enumerate}
%
%\section{Sampling the Scene}
%The goal of this stage of the algorithm is to sample the scene geometry (including the volume) and store the direct lighting in a finite data representation to be used later for global illumination lighting effects.  As all of our finite data represents the direct lighting of some small portion of a surface or element in a three-dimensional scene, we refer to the union of all finite lighting samples as a ``point cloud''.  This point cloud is stored in an octree representation for efficient access to all data elements, surfels and lvoxels.  Surfels differ from lvoxels only in that surfels represent a flat, solid geometry while lvoxels represent a transparent, volumetric medium.  Both have radii and position so both can be placed within the same point cloud.  
%
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=100mm]{img/diag/surfel_samp.pdf}
%    \captionfonts
%    \caption{Rays are cast from a special camera during the surfel sample phase.  Each time the ray intersects with geometry a surfel is created.}
%    \label{fig:surf_sample}
%\end{figure}
%
%\subsection{Surfel Sampling}
%
%We sample the opaque geometry in surfels, which are computed using an abstract sampling camera with a field of view slightly larger then the current viewing frustum, with a sampling rate two times that of the desired pixel resolution.  Rays are cast from the sampling camera and intersections with geometry mark sample points as seen in Figure \ref{fig:surf_sample}, giving the scene a view-dependent, thorough sample set.
%
%\subsection{LVoxel Sampling}
%
%Lvoxels are generated by marching over the entire domain of the volume by a specific, preset interval, sampling scatter and absorption coefficients in order to get an average throughout the area an lvoxel will occupy.  Typically this involves eight to sixteen absorption and scatter samples per lvoxel.  These values, as well as the radius of the lvoxels, may differ depending on the complexity and raw resolution of the volume.
%
%Caching the direct light contribution at each lvoxel by testing the transmittance using Equation (\ref{transmittion_eq}) to each light source saves us from re-computing light calculations during sampling in sections \ref{scatterout_sec} and \ref{scatterin_sec} \cite{signotes:2010}.
%
%\section{Gathering Light}
%
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=80mm]{img/diag/orthnormal.pdf}
%    \captionfonts
%    \caption{Basis vectors are generated based on the surface normal in order to transform samples on a hemisphere to test surrounding radiance.}
%    \label{fig:orthonormal}
%\end{figure}
%
%\subsection{Point-Cloud Ray Casting}
%
%Next, our algorithm uses a gather stage similar to the one in PCB, which calculates the irradiance at a point on a surface, given the radiance of the scene around it.  Unlike PCB, which uses a software rasterization method, we chose to evaluate irradiance by ray casting into the point-cloud around a hemisphere oriented along the surface's normal.  The decision to cast out of a hemisphere rather than using a software rasterization technique as was adopted in previous PCB implementations was made to simplify the tests which compare traditional Monte Carlo sampling methods to the extended PCB algorithm, but also to simplify evaluation of the transparent lvoxels within the octree.
%
%\subsection{Hemisphere Sampling}
%
%In order to approximate the integral of incoming light at point $p$ on the surface, we sample across a hemisphere oriented along the surface's normal $N$ at $\textup{p}$ as seen in Figure \ref{fig:orthonormal}.  This process is broken down into two distinct steps:
%
%\begin{enumerate}
%    \item The rays must sample across a hemisphere in an equally distributed fashion in order to gain an acceptable sampling of the surrounding radiance
%    \item Each sample ray must then be transformed based on the intersection surface's normal
%\end{enumerate}
%
%It is necessary to consider the sampling method just as important as the evaluation of those samples.  Generating purely random rays leads to clumping and high levels of noise, so a stratified sampling method was chosen, subdividing the sample space equally into a two-dimensional grid and jittering within the grid.  This helps us avoid clumping issues, and guarantees an even distribution over the entire domain.  In order to map this two dimensional domain over our hemisphere, we chose the following mapping code (converted from a function over spherical coordinates):
%
%% (based off of a cosine weighted hemisphere sampling method in Physically Based Ray Tracing \cite{pbrt})
%
%\begin{lstlisting}
%Vec3 sampleToHCoord(float us, float ts) {
%    const float r = sqrt(1. - us);
%    const float theta = 2 * PI * ts;
%    const float x = r * cosf(theta);
%    const float y = r * sinf(theta);
%    return Vec3(x, y, sqrt(us));
%}
%\end{lstlisting}
%
%Note that $sqrt(us)$ represents the Z value of the hemispherical sample (with the normal naturally placed down the Z plane.)  $sqrt(1. - us)$ represents the radius and $ts$ covers the theta (or angle around the normal of the hemisphere.)
%
%In order to force a regular distribution over this mapping equation, we chose to employ a common sampling technique over $us$ and $ts$, whose domains both ranged from 0.0 to 1.0.  We implemented a form of stratified stochastic sampling, which involves subdividing the domains into smaller sub-domains and randomly sampling within each sub-domain.  The major benefit to stratified stochastic sampling is the promise that the random samples are separated in their own sub-domains and are thus less likely to clump, giving us a better overall sampling over each domain.
%
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=80mm]{img/diag/gather.pdf}
%    \captionfonts
%    \caption{Gather rays are cast into the point-cloud, returning the estimated radiance coming from a given direction.  The radiance is then scaled based on the solid angle of that sample cast (based on sample count.)}
%    \label{fig:gather}
%\end{figure}
%
%In Section \ref{sec:int_vol}, we will employ a similar technique for sampling over volumes, but instead of sampling over hemispheres, we will sample over the domain of a sphere.  Therefore, the only necessary change is to our mapping function.  We remap $us$ to span from a range from -1.0 to 1.0, taking into account both hemispheres of the sphere.  The rest of the mapping function is basically the same:
%
%\begin{lstlisting}
%inline Vec3 sampleToSCoord(float us, float ts) {
%    const float z = 1.f - 2.f * us;
%    const float r = sqrt(max(0.f, 1.f - z * z));
%    const float phi = 2.f * PI * ts;
%    const float x = r * cos(phi);
%    const float y = r * sin(phi);
%    return Vec3(x, y, z);
%}
%\end{lstlisting}
%
%Now that we have an equally distributed set of rays over the hemisphere, we must orient all of them by the normal of the intersected surface.  We do this by creating an orthonormal basis matrix using the normal as our projected Z axis.  This matrix is saved for later when we apply the matrix to the sample rays.
%
%\begin{lstlisting}
%void orient(Vec3 normal) {
%    Vec3 up = Vec3(0,1,0);
%    Vec3 w = normal;
%    Vec3 u;
%    Vec3 v;
%    w.norm();
%    if(w.y() >= 0.9995 || w.y() <= -0.995) {
%        u = Vec3(1,0,0);
%        v = Vec3(0,0,1);
%    }else{
%        up.cross(w, &u);
%        u.norm();
%        w.cross(u, &v);
%    }
%
%    MyMat m = MyMat(u.x(), v.x(), w.x(), 0,
%                    u.y(), v.y(), w.y(), 0,
%                    u.z(), v.z(), w.z(), 0,
%                    0,     0,     0,     1);
%}
%\end{lstlisting}
%
%Each sample cast out from $p$ evaluates $L(\textup{p} \leftarrow w)$ (as shown in Figure \ref{fig:gather},) which is then multiplied by the scalar $w \cdot N$ in order to represent $cos\theta$.  In order to obtain good results, 128-256 samples are typically necessary to combat noise caused by the samples.  The resulting irradiance from the weighted sum of the samples is normalized by multiplying the normalization factor for the given phase function.
%
%%The \textit{probability density function} (PDF) describes the relative probability of a random variable taking on a particular value, and is important 
%
%%Applying these samples is a trivial matter, as each sample contributes according to the area of the cone of which that sample represents.  It is important to remember that these samples are estimating an integral that evaluates to 1.  With this in mind, consider the following equation, where $\theta_{max}$ is considered the max divergence from our surface normal.
%
%
%%\begin{equation}
%%\mathit{p}(x) = \frac{1}{Area_{cone}} = \frac{1}{Area_{hemisphere} * Fraction_{cone}} = \frac{1}{2\pi(1 - \textup{cos}\theta_{max})}.
%%\label{eq:source}
%%\end{equation}
%
%%Which leaves us with a PDF of $\frac{1}{2\pi}$, a value 
%
%\section{Integrating Volume Data}
%\label{sec:int_vol}
%In order for \textit{lvoxels} to contribute meaningfully to our scene during the light gather stage, we must make some architectural modifications to the algorithm in order to handle 1) more than one sample type in our octree and 2) the ability to handle non-opaque samples.  Both of these required simple changes in the octree data-structure as well as modification of the traversal algorithm used.
%
%\subsection{Data-Structure Modifications}
%Modifications to the previously mentioned irradiance sampling technique in order to allow scatter-out effects with volumes are few.  The biggest changes are to the point cloud octree and its traversal.  Specifically, when computing lighting, we must account for the fact that when an element of the point cloud is hit, it may be transparent.  In the standard algorithm, absorption and transmittance would not be taken into account and the traversal would stop at the first lvoxel encountered.
%
%Therefore, our algorithm must fulfill the following requirements: 1) The algorithm must ensure that the \textit{lvoxels} are placed in the same octree data-structure as the \textit{surfels}, 2) Our algorithm must keep track of the current Transmittance in order to determine the contribution of all samples encountered and 3) We must traverse the leaf nodes of the scene from front-to-back in order to integrate transparent sample contributions correctly.
%
%\subsection{Octree Traversal}
%
%In order to properly evaluate transparent and opaque surfaces within the point cloud, we made changes to node-level octree traversal.  Each branch traverses its children from closest to farthest, guaranteeing that closer leaf nodes are evaluated first.  Leaf nodes then use the pre-evaluated scatter ($\sigma_{s}$) and absorption ($\sigma_{t}$) coefficients for each lvoxel to appropriately alter the sample ray's transmittance, and continue with the traversal, with each hit contributing to the final resulting radiance value.  Once a surfel is hit, there is no need to continue traversing the octree as seen in Figure \ref{fig:testing}.
%
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=100mm]{img/testing.png}
%    \caption{Illustrates the octree traversal algorithm testing efficiency.  Lighter shades represent less tests, while darker shades represents the most.  Closer objects evaluate faster, and all data in the point-cloud behind them are occluded.}
%    \label{fig:testing}
%\end{figure}
%
%%------------------------------------------------------------%
%\subsection{Acquiring Scatter-Out Contributions}
%\label{scatterout_sec}
%
%Once the changes to the point-cloud data-structure have been made, we are able to 1) ensure correct evaluation of the transparent surfaces through front-to-back octree traversal and 2) stop evaluating leaf nodes once we have hit an opaque surfel, reducing the overall sample count.  Now that \textit{lvoxels} are supported, we simply sample the scene as we have with regular PCB.  The modified traversal algorithm already takes care of transmittance through any transparent media so no further changes are necessary.
%
%%------------------------------------------------------------%
%\subsection{Acquiring Scatter-In Contributions}
%\label{scatterin_sec}
%After adding lvoxels to our octree structure and evaluation algorithm, the only modifications necessary for scatter-in are within the volume rendering equation.  As an overview, volume integration will step through the volume, at each point it will:
%
%\begin{enumerate}
%\item Update the current transmittance by the scatter and absorption terms at the given point
%\item Cast shadow rays to estimate the direct light (and in cases of non-uniform scatter, apply a phase function)
%\item Sample scatter contribution by sending rays out into the point cloud
%\item Add direct illumination contribution and indirect illumination to the current incoming radiance
%\end{enumerate}
%
%In order to model lighting for a volume, in-scattering requires integrating over all directions (over the domain of the surrounding sphere.)  Casting Monte Carlo sample rays through the volume and into the scene would be computationally expensive, specifically because we would be almost guaranteed to integrate over the volume at every sample.  Instead, for each sample we send out rays into the point cloud, iterating through a much less dense dataset like in Figure \ref{fig:scatter_in}.  This dataset represents the volume and the surrounding polygonal geometry, giving us the indirect lighting component from both simultaneously.
%
%This method helps us replace expensive $S(\textup{p, w})$ evaluations with traversals into the octree.  The two main differences between sampling scattered light within a volume and evaluating the irradiance on a surface are 1) the distribution function, which is based on the volume's phase function, and 2) the samples are distributed over a sphere rather than a hemisphere.
%
%These scatter samples are distributed throughout the volume marching process typically taken while rendering volumes as seen in Figure \ref{fig:vol_step}.  More specifically, a single spherical sampler is kept throughout the integration of the volume over the ray.  This sampler keeps track of eight sub-samplers, each given a portion of the overall spherical domain.  For each sample step, one of the eight subsamples is randomly chosen to generate sixteen rays to cast into the scene.  The overall effect is an eventual distribution of rays over the sphere across four to eight sample steps.  We found that the sample steps were small enough that the difference in location was minuscule.  These sample points then gather from the point cloud like traditional sample rays.
%
%
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=90mm]{img/diag/scatter_in.pdf}
%    \captionfonts
%    \caption{Sample rays are cast during volume traversal, allowing for decent estimates of lighting contribution at each point.}
%    \label{fig:scatter_in}
%\end{figure}
%
%
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=90mm]{img/diag/vol_step.pdf}
%    \captionfonts
%    \caption{Stepping allows for estimation of the integral through the entire volume.  Shadow rays are cast intermittently to estimate the direct lighting contribution. }
%    \label{fig:vol_step}
%\end{figure}
%
%
%
%%------------------------------------------------------------%
%\section{Review}
%
%The following is a detailed recap of the steps described above:
%
%Step 1:  We build a logical sampling camera and pull it back behind our regular view camera (how far depends on the scene geometry.)  The viewing angle is increased (in our tests, a viewing angle of $60^{\circ}$ was ideal) and sampled at two times the resolution of the image.  These samples, generated from the sampling camera, are cast out into the scene and intersect with the polygonal geometry (Figure \ref{fig:surf_sample}.)  At each intersection point, a surfel is generated.  The created surfel's radius is dependent on the sample resolution.  Each surfel is placed inside of an octree which constitutes the acceleration structure for the point cloud.\\
%
%Step 2:  We iterate over the domain of the participating media (or, more specifically, the bounding box surrounding the volume like in Figure \ref{fig:vol_step}), stepping over a three dimensional grid with a stepping distance based on the complexity of the volume.  At each point, we generate an lvoxel, a sphere with a radius large enough to cover the stepping distance.  In order to approximate the scatter, absorption and lighting contributions for each lvoxel, we sample a number of voxels (between 16 and 32) within the area the lvoxel resides and average the values for each.\\
%
%Step 3:  After the scene data has been properly sampled, we use our view camera to cast out rays for the normal ray cast.  Each ray represents a pixel in the image, and the resulting lighting contribution will be placed as the pixel value after the ray returns.  If the ray intersects geometry, we create a hemisphere sampler which generally generates between 128 and 256 rays (Figure: \ref{fig:orthonormal}) and orient the rays to the intersected surface's normal (Figure: \ref{fig:gather}.)\\
%
%Step 4:  The sample rays will traverse the octree in a closest-to-farthest fashion.  An overall transmittance value will be initialized starting with a default of full transmittance.  As the ray steps through octree leaf nodes, the ray is tested against any lvoxels within each node, adding to the gathered light and modifying the transmittance according to the scatter and absorption properties of each lvoxel.  Once a surfel is hit, the returning irradiance is multiplied by the transmittance and the light contribution is totaled up. Each sample ray is cosine-weighted by its angle from the surface normal and scaled by a distance attenuation factor, each ray computed with the following equation:
%
%\begin{equation}
%    L_{sample} = (K_{volume} + Tr * \frac{K_{amb}}{atten * t ^ 2})\:(N \cdot w) %\int L(\textup{p} \leftarrow w) cos\theta dw
%    \label{eq:sample_radiance}
%\end{equation}
%
%
%Where $L_{sample}$ represents the outgoing light from a given sample. $K_{volume}$ is the final evaluation of all incoming light from lvoxel scatter-in and scatter-out, while $Tr$ is the end-transmittance when the ray hits a surfel.  $K_{amb}$ is the irradiance coming from the surfel that the ray hits (or black if it misses all surfels.)  Attenuation is applied to the irradiance by dividing by the distance squared (or $t^2$) with an attenuation factor $atten$ to modify its effect.  The resulting radiance is then weighed by $N * w$, which represents the cosine weight between the surface normal $N$ and the sample direction $w$.  After summing up all of the samples in Equation \ref{eq:sample_radiance}, we are left with the following equation to return the final ray color:
%
%\begin{equation}
%    L_{final} = K_{diffuse} + \frac{L_{iTot}}{N_{samples}} %\int L(\textup{p} \leftarrow w) cos\theta dw
%    \label{eq:sample_final}
%\end{equation}
%
%
%
%Where $K_{diffuse}$ represents the direct lighting component for the intersect point, $L_{iTot}$ is the summation of the $N_{samples}$ samples cast into the scene. % and p represents the intersection point.  $L_f$ is then the returned radiance from that ray.\\
%
%Step 5:  If the ray tracing rays step through a volume, samples are cast out at every sample step (Figure: \ref{fig:scatter_in}.)  All samples across a stepping ray share the same spherical sampler, sampling approximately 16 rays per sample step.  Each step will not guarantee a full distribution over the sphere, but over four to eight samples, a full distribution should be reached.  We have found that this approximation is adequate and that no noticeable difference was seen compared to other heavier sampling methods that attempted full sample distribution for every sample step.\\
%
%Step 6:  After casting rays into the scene and evaluating the radiance at each intersection (Equation: \ref{eq:sample_final}), the radiance values are returned as the final color values.  These values are gamma-corrected and converted from floating point integers into clamped integer values between 0 and 255 in order to fit the Targa image format.
%
%%==============================================================================%
%\chapter{Results}
%
%This section will discuss the testing environment and test scenario used to compare traditional Monte Carlo gather methods with the results that we were able to achieve using our PCB Extension algorithm.
%
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=120mm]{img/sponza.png}
%    \caption{Sponza Atrium mesh and Stanford bunny volume rendered using the PCB Extension algorithm.}
%    \label{fig:sponza_results}
%\end{figure}
%
%\begin{figure}[h!]
%\centering
%    \includegraphics[width=60mm]{img/bunny_spot/spot_left.png}
%    \includegraphics[width=60mm]{img/bunny_spot/spot_front.png}
%
%    \includegraphics[width=60mm]{img/bunny_spot/spot_right.png}
%    \includegraphics[width=60mm]{img/bunny_spot/spot_behind.png}
%    \captionfonts
%    \caption{A test scene showing a light's interaction with a volume changing depending on the direction and position of the light.}
%\end{figure}
%
%\section{Environment}
%
%Our algorithm is able to achieve realistic lighting effects for scenes that include volumetric elements using our lvoxel representation with a point-based color bleeding approach to global illumination.
%The following test cases were run on a commodity-class Intel i5 3 GHz machine with 16 Gb of RAM.  Because of the disparity between academic-level versus production-class ray tracer implementations, we tested and compared our results against a naive implementation of Monte Carlo global illumination not using the point cloud representation.  We then compared the resulting images and the time it took to render each.  Our algorithm is able to achieve a small difference between images and an increase in efficiency measured in time to render.
%
%We parallelized our ray tracer by cutting the image into vertical slices for each thread to compute simultaneously with the help of OpenMP, which showed us a four times speedup across the board.
%
%\section{Test Scene}
%
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=120mm]{img/sponza_vis.png}
%    \captionfonts
%    \caption{Real-time visualization of the Sponza Atrium mesh in MeshLab.}
%    \label{fig:sponza_meshlab}
%\end{figure}
%
%The scene tested involved a 60,000 triangle Sponza Atrium including only vertex and normal information for simplicity.  The CT scan data of the Stanford Bunny was used in order to test scatter in/out contributions by complex participating media.
%Figure~\ref{fig:compare} shows the bunny and Sponza Atrium showing traditional Monte Carlo scattering.  At first glance these two images are very similar, however there are a number of small artifacts present in the image rendered with the point cloud representation, and the indirect lighting is slightly darker overall.  A closer look at the two results exemplifies the great similarity between the two images, as shown in Figure~\ref{fig:compare_close}.
%
%Every test rendered a 640x480 image with 128 light samples per ray.
%
%%------------------------------------------------------------%
%\section{Data Comparison}
%
%\setlength{\tabcolsep}{5pt}
%
%\begin{table}
%\begin{center}
%\begin{tabular}{ | l | c | c | c | }
%  \hline                       
%  Scene & Render Time (s) & Image Delta & Memory Overhead \\
%
%  \hline
%  \multicolumn{4}{|c|}{$64^3$ resolution volume} \\     
%  \hline            
%
%  Monte Carlo w/o PCB & 3229 sec & NONE & NONE \\
%  Traditional PCB & 348 sec & 5.8\% & 466.3 MB (4.780\%) \\
%  Extended PCB & 433 sec & 2.1\% & 466.7 MB (4.786\%)  \\
%
%  \hline
%  \multicolumn{4}{|c|}{$128^3$ resolution volume} \\     
%  \hline            
%             
%  Monte Carlo w/o PCB & 3297 sec & NONE & NONE \\
%  Traditional PCB & 348 sec & 5.6\% & 466.3 MB (4.780\%) \\
%  Extended PCB & 402 sec & 2.4\% & 467.5 MB (4.783\%)  \\
%
%  \hline
%  \multicolumn{4}{|c|}{$512^3$ resolution volume} \\     
%  \hline            
%             
%  Monte Carlo w/o PCB & 3674 sec & NONE & NONE \\
%  Traditional PCB & 348 sec & 9.6\% & 466.3 MB (4.780\%) \\
%  Extended PCB & 417 sec & 3.8\% & 466.4 MB (4.785\%)  \\
%  \hline  
%
%\end{tabular}
%\caption{Sponza Scene With Stanford Bunny Volume Runtime}
%\label{tb:comparison_bunny}
%\end{center}
%\end{table}
%
%\begin{table}
%\begin{center}
%\begin{tabular}{ | l | c | c | c | }
%  \hline                       
%  Scene & Render Time (s) & Image Delta & Memory Overhead \\
%
%  \hline
%  \multicolumn{4}{|c|}{$64^3$ resolution volume} \\     
%  \hline            
%
%  Monte Carlo w/o PCB & 10150 sec & NONE & NONE \\
%  Traditional PCB & 348 sec & 14.2\% & 466.3 MB (4.780\%) \\
%  Extended PCB & 756 sec & 3.7\% & 468.0 MB (4.800\%)  \\
%
%  \hline
%  \multicolumn{4}{|c|}{$128^3$ resolution volume} \\     
%  \hline            
%             
%  Monte Carlo w/o PCB & 15811 sec & NONE & NONE \\
%  Traditional PCB & 348 sec & 14.4\% & 466.3 MB (4.780\%) \\
%  Extended PCB & 755 sec & 4.2\% & 467.3 MB (4.790\%)  \\
%
%  \hline
%  \multicolumn{4}{|c|}{$256^3$ resolution volume} \\     
%  \hline            
%             
%  Monte Carlo w/o PCB & 31373 sec & NONE & NONE \\
%  Traditional PCB & 348 sec & 14.2\% & 466.3 MB (4.780\%) \\
%  Extended PCB & 864 sec & 4.3\% & 467.1 MB (4.790\%)  \\
%  \hline  
%\end{tabular}
%\caption{Sponza Scene With CT Head Volume Runtime}
%\label{tb:comparison_head}
%\end{center}
%\end{table}
%
%
%%------------------------------------------------------------%
%\section{Analysis}
%Our analysis involves comparing 1) the overall render time 2) the perceived image delta between the images and 3) the memory overhead used by the point-cloud data.  Two volume sets were sampled at differing resolutions (as seen in Tables \ref{tb:comparison_bunny} and \ref{tb:comparison_head}.)
%
%%----------------------------------%
%\subsection{Memory}
%In all tests, the memory overhead for PCB and PCBEX was much smaller than that of the scene it represented.  When using traditional PCB, the real benefit to its surfel representation is shown in more complex scenes.  In the Sponza Atrium, the scene generated over 2.5 million surfels for a 60,000 triangle scene.  Adding volume data to the scene does not add a notable amount of data to the point cloud, but for scenes with large volumes the costs could quickly add up without some form of multi-resolution light caching.  In this regard, adding yet another representation of the volumes may be expensive, but not prohibitively so.  Additionally, larger scenes would benefit from this representation, as it would be significantly simpler than the entire scene and can be moved to another system for out-of-core evaluation.
%
%Comparing Tables \ref{tb:comparison_bunny} and \ref{tb:comparison_head} shows a significant discrepancy of run time and memory overhead for all tests.  This is mostly due to the fact that the CT head model is entirely solid, whereas the Stanford bunny volume has significant empty space inside and outside that the volume integrators could take advantage of.  Complex volumes, like that of the CT head scan, are where this algorithm really shines, with a total speedup factor of over thirty-six times that of the traditional Monte Carlo render.  This was also where the lvoxel data structure was the most expensive, however that amount was still small (in the range of 2 to 3MB.)
%
%%----------------------------------%
%\subsection{Speed}
%Even when disregarding volume integration, Monte Carlo integration without a lighting representation like PCB is prohibitively slow for even the simplest scenes.  Adding a point cloud representation gave us a surprising speedup.  That speedup was pronounced when volume scattering was added into the tests, showing run-times on the order of magnitudes shorter than the Monte Carlo renders.
%
%Even on sparse octrees without volumes, our \textit{front to back} octree traversal method operates at an efficiency of $O\log{n}$ for each node traversal while skipping nodes occluded by surfels, leading to an average performance increase of over 18\%.
%
%%----------------------------------%
%\subsection*{Image Quality}
%
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=100mm]{img/compare.png}
%    \caption{Bunny Scene comparison of the PCB extension (left) and traditional Monte Carlo results (right.)}
%    \label{fig:compare1}
%\end{figure}
%
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=100mm]{img/compare_head.png}
%    \caption{CT Head scene comparison of the PCB extension (left) and traditional Monte Carlo results (right.)}
%    \label{fig:compare2}
%\end{figure}
%
%Figures \ref{fig:compare1} and \ref{fig:compare2} show a comparison between Monte Carlo and PCBEX render results.  In order to objectively compare the image results, we used a perceptual image difference program called pdiff and ran the pair of images through in order to identify how close the two images were to each other.  The results are shown in tables \ref{tb:comparison_bunny} and \ref{tb:comparison_head}, which ranged from 2.1\% and 4.3\%.
%
%
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=80mm]{img/compare1_corrected.png}
%    \captionfonts
%    \caption{Zoomed image showing PCB extension (left) and Monte Carlo (right.)}
%    \label{fig:compare_close}
%\end{figure}
%
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=80mm]{img/compare_trad_corrected.png}
%    \captionfonts
%    \caption{Zoomed image showing traditional PCB (left) and PCB with extension (right.)  Note the visible color bleeding with our method.}
%    \label{fig:compare_trad}
%\end{figure}
%
%Figure~\ref{fig:compare_trad} compares the non-PCB Monte Carlo image with that of the traditional PCB renders, showing the clear lack of proper in-/out-scattering.  With the extended algorithm, however, the scenes look nearly identical.
%
%We noticed a dramatic jump in image difference between the $128^3$ resolution bunny model and the $512^3$ resolution model.  We believe that, because we used the same surfel sizes for all volume resolutions, that this discrepancy was caused by the complexity of the bunny volume.  Because the voxels were smaller, there is more room for error using larger lvoxels.  In real-world application we assume that lvoxels of much smaller size would be sampled and used in renders to mitigate this problem.
%
%We would like to note that there are a number of small artifacts in the PCB renders due to imprecision and incorrect surfel collisions.  It is important to note that, as past papers will attest, such issues are easily overcome and our artifacts are more due to implementation and time constraints than limits on the algorithm itself.
%
%\subsection{Scalability}
%
%The usefulness of the point cloud representation depends heavily on the cost of sampling the octree versus sampling the original scene geometry.  In our paper we assume that the cost of traversing the octree in a front-to-back order and sampling the point cloud is more efficient than sampling the polygonal meshes and integrating through the volumes.  Simpler scenes (such as the Cornell box) would only benefit from this algorithm given a complex or large volume to sample inside.
%
%Though we can compare and contrast specific sections of our algorithm to that of traditional Monte Carlo, the overall worst case run time is hard to evaluate.  Consider, first, the difficulty in evaluating overall scene complexity, which depends heavily on the acceleration structure being used (and all of the complexity that entails.)  We know for certain that the initial child lookup within our octree will give us a complexity of $n log(n)$.  Subsequent traversal of leaf nodes would be significantly less due to the recursive nature of our algorithm.
%
%We can estimate the total cost by multiplying the tests required for each leaf node by the total leaf nodes the ray will hit within an octree.  With that in mind, a theoretical worst case scene would involve a lot of close geometry (resulting in a deeply subdivided octree) and a camera orientation that would guarantee that most of the rays pass through most octree nodes.
%
%Using the point cloud to sample radiance in our test scenes showed a clear improvement over Monte Carlo sampling the original geometry.  With other companies like DreamWorks Animation and Disney employing the point-based color bleeding algorithm, it is clear they have found the point cloud representations to have faster evaluation times than the full scene geometry in production.  With the assumption that the point cloud does not get \textit{more} complex than the scene it is sampling, we can safely guess that we will see similar speedups.
%
%
%\section{Known Limitations}
%\label{sec:knownlimits}
%
%One problem we identified is that the algorithm assumes that there are no transparent polygonal surfaces in the scene.  Only completely opaque surfels are considered in our algorithm, and transparent polygonal surfaces would still return, not going further into the point cloud.  In fact, our surfel representation does not even have any notion of transparency.
%
%\vspace{5mm}
%
%We did not compare other volume integration/in-scattering acceleration structures which may have been a better suited comparison than that of strict integration of the participating media.  Other BSSRDF algorithms will follow a method similar to ours, creating nodes within the volume (or polygonal mesh) which approximate irradiance at each point.  These nodes allow for faster lookup of scatter lighting contribution within the object, allowing their algorithm to essentially skip proper volume integration (which is one of the most costly parts of the full Monte Carlo rendering algorithm.)
%
%\vspace{5mm}
%
%Because our volume phase function was isotropic (evaluating equal scatter in all directions,) we only had to keep track of one irradiance value in each lvoxel.  In a more complex system, we would use a better representation of the radiance scattering (perhaps through a spherical harmonic representation) which would push up the size of each lvoxel considerably.  This may cause the lvoxel point cloud to become more memory-intensive, but we do not foresee this as being excessively expensive.
%
%\section{Conclusion}
%In this paper, we discussed the necessity for proper global illumination approximations in renders, listed a number of algorithms that have attempted to do this but have fallen short specifically in volume scatter contributions, and presented an extension to the PCB algorithm by \cite{christensen:2008} which handles both scatter-in and scatter-out contributions.  The addition of the lvoxel paradigm to the already successful point-based color bleeding algorithm is shown to be a cost effective method of approximating and evaluating complex scatter functions based on participating media.  We obtained render speeds up to 36 times faster than that of pure Monte Carlo renders with a memory overhead between 2 to 5 MB with an image difference of less than 5\% across all tests.
%
%Computer graphics, be it photo-realistic or artistically leaning, relies heavily on the paradigms established in the physics of light in the real world.  Global illumination is just one of many areas of focus trying to better represent that light and its complex interactions in the abstract worlds we choose to bring to screen.  One can only imagine the leaps and bounds that computer graphics is destined to experience in the following years, but inevitably the obstacles boil down to the same subset of problems.  How to manipulate light and, by extension, color in order to make the viewer experience a story or emotion.
%
%%==============================================================================%
%\chapter{Future Work}
%
%
%As mentioned in Christensen's point based color bleeding article, surfels can be modified to ``gather'' light recursively from their position in the point cloud, allowing for simulated multi-bounce lighting.  This would require only a small change to the current algorithm, and would apply to volumes as well to allow very realistic scatter approximations in participating media.
%
%\vspace{5mm}
%
%In our tests, all participating media scatters light equally in all directions.  This is rarely the case, as volumes tend to have unique scatter functions.  We can simulate more complex surface scattering functions by creating spherical harmonic representations of the radiance at any specific point in the volume.  Our current implementation supports such an approach, but remains untested.
%
%\vspace{5mm}
%
%Typical implementations of the PCB algorithm include rougher estimations (usually in the form of a series of spherical harmonic coefficients) at higher levels in the octree, to be evaluated depending on that node's solid angle to our sample point.  Due to time constraints, we did not implement full multi-resolution representations of each node.  Including LVoxel data in that representation would be a trivial process.
%
%\vspace{5mm}
%
%As mentioned in Section \ref{sec:knownlimits}, we do not handle transparent objects in our algorithm.  This would likely involve a minor change to volume integration to include transparent surfels as well.
%
%\vspace{5mm}
%
%Our ray tracer runs a number of threads to split the image into multiple parts  in order to achieve simple parallelism.  Before the threads are created, however, we generate surfels and lvoxels sequentially.  Due to the nature of our octree implementation, we cannot add elements and still be thread safe, but this would not be a large obstacle.  Scenes like the sponza atrium would run a number of times faster if we were to parallelize our implementation more effectively.
%
%\vspace{5mm}
%
%Although for our purposes ray casting the scene to sample for surfels worked well, it is most certainly not an optimal algorithm.  Sampling the scene in a more geometry- aware fashion would lead to fewer samples and better results.  Subdividing the scene into smaller polygons and sampling the scene (say, one or two surfels per micro-polygon) would increase our coverage while decreasing unnecessary overlap.  We found that the simpler approach worked best for us, given our time frame, however it can most certainly be improved.
%
%\vspace{5mm}
%
%Because the color-bleeding effect in PCB focuses primarily on the point-cloud data, we are offered a unique opportunity to consider offloading the entire octree structure out-of-core in order to outsource the (still computationally complex) algorithm onto other machines, if not to on-board GPUs.  Taking advantage of a graphics processor's fast math and hardware rasterization would allow for much faster indirect-lighting evaluations.
%
%% ------------- End main chapters ----------------------
%
%\clearpage
%\bibliography{thesis}
%\bibliographystyle{plain}
%%\addcontentsline{toc}{chapter}{Bibliography}
%
%
%
%%==============================================================================%
%
%\section*{Image Results}
%
%\begin{figure}[h!]
%    \centering
%    \includegraphics[height=90mm]{img/sponza.png}
%    \captionfonts
%    \caption{The Sponza Atrium with the Stanford volumetric bunny.  In and Out-scattering are evident on the volume and on the surrounding atrium walls.}
%\end{figure}
%
%\begin{figure}[h!]
%    \centering
%    \includegraphics[height=90mm]{img/indirect_box_high.png}
%    \captionfonts
%    \caption{Example of point-based color bleeding without the volume extension algorithm.}
%\end{figure}
%
%\begin{figure}[h!]
%    \centering
%    \includegraphics[height=90mm]{img/two_sphere_indir.png}
%    \captionfonts
%    \caption{Example of a scene almost entirely in shadow, showing indirect lighting in play.}
%\end{figure}
%
%\begin{figure}[h!]
%    \centering
%    \includegraphics[height=90mm]{img/ketchup_good_corrected.png}
%    \captionfonts
%    \caption{Image exemplifying clear out-scattering from Stanford bunny volume.}
%\end{figure}
%
%\begin{figure}[h!]
%    \centering
%    \includegraphics[height=90mm]{img/bunny_spot/spot_right_new.png}
%    \captionfonts
%    \caption{Image exemplifying clear color bleeding next to the red wall in the bunny's shadow and correct transmittance through the bunny's hollow form.}
%\end{figure}
%
%\begin{figure}[h!]
%    \centering
%    \includegraphics[height=90mm]{img/one_side_corrected.png}
%    \captionfonts
%    \caption{The black occluding geometry in the center stops all but the light to the left to enter below.}
%\end{figure}
%
%\begin{figure}[h!]
%    \centering
%    \includegraphics[height=90mm]{img/bunny_glow.png}
%    \captionfonts
%    \caption{Illustrates how a light may act when placed within a hollow volumetric object.  The bunny is shown as slightly brighter, scattering light about the scene.}
%\end{figure}
%
%\begin{figure}[h!]
%    \centering
%    \includegraphics[height=90mm]{img/face1.png}
%    \captionfonts
%    \caption{Shows how CT scan data can be used to visualize scanned objects like a human face.  Subsurface scattering and transmittance through thin materials are evident.}
%\end{figure}



\end{document} %much faster 
